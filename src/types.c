/*
   Исполнитель языка ll работает с пространствами имён

   namespace
     name: String,
     ns: String -> namespace      ;; Функция смены пространства имён. Возвращает пространство имён по имени

 */

/*
  ll - lack of language

  Для языка необходим способ комбинации и упорядочивания объектов,
  в языке ll тем выступает функтор, более - здесь всё есть функтор!

  * |-> functor

  functor functor -> functor

  Нужны пространства имён, т.к. какой язык программирования обходится без имён
  Пространство имён суть представляет собой некоторую сигнатуру
  Сигнатуру с порядком инициализации её элементов
  Каждый последующий элемент является замыканием для предыдущего
  (может быть это работает быстрее произвольного порядка иницализации, надо подумать)
  Сигнатура под собой имеет ассоциативный массив, тот, соответственно, может иметь порядок,
  может не иметь

  Короче нужна нам реализация списков, ассоциативных массивов на функторах, а на них уже,
  если то нужно в процессе реализации какой-либо системы, строятся абстрактные типы данных

  Нужны какие-то базовые операции помимо композиции для абстрактного вычислителя,
  чтобы составлять из функторов другие структуры данных

  Здесь подход таков, что функция, функтор, морфизмы и пр. в данном контексте
  имеющие схожий смысл понятия становятся не отдельными типами данных от таких как:
  списки, ассоциативные массивы, множества, сигнатуры, классы, числа, а являются
  для них основой, одним целым с ними

  Так, в Лиспах функция всегда отдельный тип данных, в ML'ях история такова же

  ---

  a -> b b -> c cons -> a -> b -> c

  a -> b tail -> b

  a -> b -> c tail -> b -> c

  a -> b head -> a

  a -> b b -> c compose -> a -> c

  b -> c a abstract -> a -> b -> c

  a -> b -> c a apply -> b -> c

  a -> b b -> c abstract -> a -> b -> b -> c

  a -> b c -> d system -> a -> b -> ^ -> c -> d

  a -> b

  где ^ - разделитель элементов в функторе

  С его добавлением операция apply начинает вести себя иначе
  Вместо мгновенного сопоставления аргумента с первым параметром начинается
  поиск подходящих параметров, где шагом является переход между элементами,
  разделёнными ^

  Со списками логика схожа

  ---


 */

// structure
// function
// sequence
// closure
// algorithm
